<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="label3.Text" xml:space="preserve">
    <value>SSH passwords:  Configure as explained to the right.
Connect to each remote PC using SSH and enter
"Yes" to allow the connection.  If the Username below
is not the same as the remote PC then be sure to 
enter the correct username using the form 
Remote Projects and PCs.  If you configure SSH to
remember passwords then there is no need to set
any SSH passwords in this app.</value>
  </data>
  <data name="label2.Text" xml:space="preserve">
    <value>This app expects that the Boinc and SSH ports are
31416 and 22 respectively.  No passwords are used
to access Boinc and you must configure Boinc to
allow remote access.  Boinc must be installed and
running on the host system.  If SSH is not used
then this app is limited in what it can do.</value>
  </data>
  <data name="textBox1.Text" xml:space="preserve">
    <value>The following is for Windows 11 and an administrator (not a user)
It is based on this Windows 10 configuration and OpenSSH setup for a user

Do the following on each remote system

Ensure that networking (file sharing) is enabled on the remote Windows PC (the server).
OpenSSH server must be installed in windows using Add Optional Features
On Windows 11:
Go to Settings &gt; System &gt; Optional features and click on View features.
Locate “OpenSSH server” feature, select it, click Next, and then click Add.

Bring up services and set both the OpenSSH agent and the server to automatic start 
Start both the agent and the server

Go to c:\programdata\ssh and edit sshd_config to add the following three items

PasswordAuthentication yes
PubkeyAuthentication yes
StrictModes no

after installing, bring up services and enabled OpenSSH authenticator and OpenSSH to start automatically
Ensure that networking (file sharing) is enabled on the Windows PC.
To avoid having to supply a password you must create an SSH key on the controlling PC and copy it to each remote system



on local system controlling the remote PCs, log in as administrator and bring up the admin command prompt
and copy and paste to run the following. Change USERNAME WINDOWS_USERNAME to your username and your
Microsoft windows login (usually an email)

mkdir %USERPROFILE%\scripts
echo copy all your public keys to %USERPROFILE%\scripts
echo press return when ready
pause

ssh-keygen -t ed25519 -a 32 -f %USERPROFILE%/scripts/%COMPUTERNAME%
set-service ssh-agent StartupType ‘Automatic’
Start-Service ssh-agent
ssh-add "C:\Users\USERNAME\scripts\"

scp %USERPROFILE%/scripts/%COMPUTERNAME%.pub  WINDOWS_USERNAME@REMOTEPC1:c:\users\USERNAME\.ssh\authorized_keys 
scp %USERPROFILE%/scripts/%COMPUTERNAME%.pub  WINDOWS_USERNAME@REMOTEPC2:c:\users\USERNAME\.ssh\authorized_keys 


icacls.exe "C:\ProgramData\ssh\administrators_authorized_keys" /inheritance:r /grant "Administrators:F" /grant "SYSTEM:F"

https://woshub.com/using-ssh-key-based-authentication-on-windows/
https://woshub.com/connect-to-windows-via-ssh/


USERPROFILE will be the username:  either the microsoft email login or a local administrator account username
if not using email type login.

Copy the file %USERPROFILE%/.ssh/%COMPUTERNAME%.pub to the script folder on the controlling pc</value>
  </data>
  <data name="textBox2.Text" xml:space="preserve">
    <value>1 Install OpenSSH

sudo apt-get install openssh-server
sudo systemctl enable ssh


2 - Configure to allow files to be transferred and commands issued that normally require SUDO.

  You have install the public key from your controlling Windows PC to all your remote systems
  --windows: \ProgramData\ssh\administrators_authorized_keys
  --ubuntu: /.ssh/authorized_keys
  On all ubuntu system you need to run sudo visudo to allow "no password required" for the following
username ALL=(ALL) NOPASSWD: /bin/mv
username ALL=(ALL) NOPASSWD: /bin/systemctl restart boinc-client, \
                             /bin/systemctl stop boinc-client, \
                             /bin/systemctl start boinc-client
username ALL=(ALL) NOPASSWD: /sbin/shutdown
username ALL=(ALL) NOPASSWD: /bin/rm /var/lib/boinc/*, /bin/rm -f /var/lib/boinc/*, /bin/rm -r /var/lib/boinc/*, /bin/rm -rf /var/lib/boinc/*

</value>
  </data>
  <data name="textBox3.Text" xml:space="preserve">
    <value>In order to restart Boinc on a remote PC you must create a task to do the restart.
You must have powershell installed on each Windows PC.  You create the task by running
the script "UpdateBoinc.cmd".  You must first place the file "CopyBoinc.ps1" at the
location c:\ProgramData\boinc.  Copy and paste the scripts below.

The file UpdateBoinc.cmd.  Be sure to change YOUR_USERNAME to the windows %username%,
not your login username.  Enter echo %username% in a command prompt in case of doubt.

///////////////////////////////UpdateBoinc.cmd//////////////////////////////////////////
:: UpdatePandora.bat.  This installs a task in the windows task manager
:: that can be triggered as follows: schtasks /run /tn "CopyNewPandora"
:: Check if running as Administrator
@echo off
net session &gt;nul 2&gt;&amp;1
if  %errorlevel% neq 0 (
    echo [ERROR] This script must be run as Administrator.
    pause
    exit /b 1
)
schtasks /create ^
  /tn "CopyNewPandora" ^
  /tr  "powershell.exe -WindowStyle Hidden -NoProfile -ExecutionPolicy Bypass -File \"C:\ProgramData\boinc\CopyBoinc.ps1\"" ^
  /sc once /st 00:00 /sd 01/01/2000 ^
  /ru "YOUR_USERNAME" ^
  /rl HIGHEST ^
///////////////////////////////////////////////////////////////////////////////////////////




Here is the file that does the restart of Boinc.

////////////////////////////////////RestartBoinc//////////////////////////////////////////
# Register event source
$source = "RestartBoinc"
$log = "Application"
if (-not [System.Diagnostics.EventLog]::SourceExists($source)) {
    New-EventLog -LogName $log -Source $source
}
# stop boinc
&amp; "C:\Program Files\BOINC\boinccmd.exe" "--quit"
Start-Sleep -Seconds 10
&amp; "C:\Program Files\BOINC\boinc.exe" "--detach" "--allow_remote_gui_rpc"
///////////////////////////////////////////////////////////////////////////////////////////</value>
  </data>
  <metadata name="imageList1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>33</value>
  </metadata>
</root>